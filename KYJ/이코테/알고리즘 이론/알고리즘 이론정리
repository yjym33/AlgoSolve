1. 그리디 알고리즘

   어떠한 문제가 있을때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.
   여기서 탐욕적이라는 말은 "현재 상황에서 지금 당장 좋은 것만 고르는 방법"을 의미한다.

   그리디 알고리즘은 기준에 따라 가장 좋은 것을 선택하는 알고리즘이므로 
   문제에서 "가장 큰 순서대로", "가장 작은 순서대로"와 같은 기준을 알게 모르게 제시해준다.
   대체로 이 기준은 정렬 알고리즘을 사용했을때 만족 시킬수 있으므로 그리디 알고리즘 문제는 자주 정렬 알고리즘과 짝을 이뤄 출제된다.

   대표적인 예시로 거스름돈 문제가 있다. (예제 3-1 참고)

2. 구현

   코딩테스트에서 구현이란 '머리속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다.
   흔히 문제 해결 분야에서 구현 유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제'를 의미한다.
   이 책에서는 완전탐색, 시뮬레이션 유형을 모두 '구현' 유형으로 묶어서 다루고 있다.
   완전 탐색은 모든 경우의 수를 주저 없이 다 계산하는 해결방법을 의미하고,
   시뮬레이션은 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행해야하는 문제 유형을 의미한다.
   

   대표적인 예시의 문제로는 예제 4-1(시뮬레이션), 예제 4-2(완전탐색)을 참고한다.

3. DFS/BFS(그래프를 탐색하기 위한 두가지 알고리즘) // (코딩테스트에서 매우 자주 등장하는 문제 이므로 중요함)

   탐색 : 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
   자료구조 : 데이터를 표현하고 관리하고 처리하기 위한 구조

   DFS/BFS를 제대로 이해하기 위해서는 기본 자료구조인 "스택" 과 "큐", "재귀함수" 에 대한 이해가 전제되어야 한다.

   스택(Stack) : 박스 쌓기에 비유 가능, 선입후출 구조 (후입선출 구조)라고 한다.
   큐(Queue) : 대기 줄에 비유 가능, 선입선출 구조
   재귀함수(Recursive Function) : 자기 자신을 다시 호출하는 함수

   DFS(Depth-First Search) : 깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘, 스택(Stack) 자료구조 이용

    - 그래프(Graph) : 그래프는 노드(Node) 와 간선(Edge)로 표현, 이때 노드를 정점(Vertex)라고 부르기도 함
                     그래프는 크게 2가지 방식으로 표현 가능
                       - 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
                       - 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

   BFS(Breath First Search) : 너비 우선 탐색, 가까운 노드부터 탐색하는 알고리즘, 큐(Queue) 자료구조 이용

   DFS/BFS에서는 스택, 큐, 재귀함수, 인접행렬, 인접리스트 등 각각의 예제를 참고하여 이해한후 문제를 풀어야한다.

   4. 정렬 (연속된 데이터를 기준에 따라서 정렬하기 위한 알고리즘)

   정렬(Sorting)이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.

    - 선택 정렬 : 데이터가 무작위로 있을 때, 
                이중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복한다.
                이 방법은 가장 원시적인 방법으로 매번 '가장 작은 것을 선택' 한다는 의미에서 "선택 정렬" 알고리즘 이라고 한다.

    - 삽입 정렬 : 삽입 정렬은 선택 정렬처럼 동작 원리를 직관적으로 이해하기 쉬운 알고리즘이다. 
                특히 삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되어 있을때' 훨씬 효율적이다.
                선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 반면 삽입 정렬은 그렇지 않다.
                "삽입 정렬"은 특정한 데이터를 적절한 위치에 '삽입' 한다는 의미에서 "삽입 정렬"이라고 부른다.
                더불어 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.

    - 퀵 정렬 : 퀵 정렬은 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.
              퀵 정렬과 비교할 만큼 빠른 알고리즘으로는 '병렬 정렬' 알고리즘이 있다.
              이 두 알고리즘은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다.
              "기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?
              퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
              퀵 정렬에서는 피벗(Pivot)이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.

    - 계수 정렬 : 계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
                계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 (비교 기반의 정렬 알고리즘)이 아니다.
                계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
                
   5.  이진 탐색 알고리즘
     
     - 순차 탐색 : 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인하는 방법
     - 이진 탐색 : 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
                   > 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정합니다.

       > 코딩테스트시 알아두면 좋은 이진탐색 라이브러리

         - bisect_left(a, x): 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스를 반환
         - bisect_right(a, x): 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스를 반환

     - 파라메트릭 서치 (Parametric Search)

         > 파라메트릭 서치란 최적화 문제를 결정 문제("예" 혹은 "아니오")로 바꾸어 해결하는 기법입니다.
           - 예시 : 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제
         > 일반적으로 코딩 테스트에서 파라메트릭 서치 문제는 이진 탐색을 이용하여 해결할 수 있습니다.

   6. 다이나믹 프로그래밍

     - 컴퓨터를 활용해도 해결하기 어려운 문제는 무엇일까?, 최적의 해를 구하기에 시간이 많이 필요하거나, 메모리 공간이 매우 많이 필요한 문제들이다.
       다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬수 있는 방법이 있다.
       대표적인 방법이 바로 다이나믹 프로그래밍 기법으로 동적 계획법이라고 표현하기도 한다.
       이 책에서는 다이나믹 프로그래밍의 2가지 방식 (탑다운과 보텀업)을 설명할 것이다.
       다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다.

       다이나믹 프로그래밍을 항상 사용할수는 없으며, 다음 조건을 만족할때 사용할 수 있다.
         1. 큰 문제를 작은 문제로 나눌수 있다.
         2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
        
      다이나믹 프로그래밍 기법중에는 대표적으로 메모이제이션 기법이 있다.
      메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면
      메모한 결과를 그대로 가져오는 기법을 의미한다. 메모이제이션은 값을 저장하는 방법이므로 캐싱이라고도 한다.

      정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
      
      큰 문제를 작게 나누는 방법은 퀵 정렬에서도 소개된적이 있는데 퀵정렬은 분할정복 알고리즘으로 분류된다.
      다이나믹 프로그래밍과 분할정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.

      재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운 방식이라고 말한다.
      반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 말한다.
      탑다운 (메모이제이션) 방식은 '하향식' 이라고도 하며, 보텀업 방식은 '상향식'이라고도 한다.


      
                 
   
                        



