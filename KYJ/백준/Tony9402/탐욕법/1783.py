# 병든 나이트

# 병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

# 2칸 위로, 1칸 오른쪽
# 1칸 위로, 2칸 오른쪽
# 1칸 아래로, 2칸 오른쪽
# 2칸 아래로, 1칸 오른쪽

# 병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다.
#
# 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다.
#
# 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

# 체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

# 입력 : 첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

# 출력 : 병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.

# 예제 입력 1 : 100 50                                          예제 출력 1 : 48

# 풀이

from sys import stdin


if __name__ == '__main__':
    n, m = map(int, stdin.readline().split())

    if n == 1:
        print(1)
    elif n == 2:
        print(min(4, (m + 1) // 2))
    elif m < 7:
        print(min(4, m))
    else:
        print(m - 7 + 5)

# 접근 방법

# 문제에서 중요한 점은 다음과 같다.

# 1. 항상 나이트가 오른쪽으로만 이동한다.

# 2. 4번 "이상" 이동 시에는 모든 이동 방법이 한 번 이상씩 사용되어야 한다.

# 3. 현재 위치한 점도 포함해서 센다

# 4. 4번보다 "적은" 경우 (방문한 칸이 5개 미만인 경우)에는 이동방법에 대한 제약이 없다.

    # 위의 특징을 가지고 경우의 수를 나누어 본다면 다음과 같다.

    # N = 1
    # 방문할 수 있는 칸 : 1
    # 병든 나이트가 이동할 수 있는 4가지 방법 중 이동할 수 있는 경우가 없다.

    # N = 2
    # M = 1, 2
    # 방문할 수 있는 칸 : 1

    # M = 3, 4
    # 방문할 수 있는 칸 : 2

    # M = 5, 6
    # 방문할 수 있는 칸 : 3

    # M = 7, 8
    # 방문할 수 있는 칸 : 4

    # M = 9
    # 방문할 수 있는 칸 : 4

    # M = 10
    # 방문할 수 있는 칸 : 4
    # M에 따라 최대 4칸을 방문할 수 있다.

    # N = 3
    # M = 1
    # 방문할 수 있는 칸 : 1

    # M = 2
    # 방문할 수 있는 칸 : 2

    # M = 3
    # 방문할 수 있는 칸 : 3

    # M = 4
    # 방문할 수 있는 칸 : 4

    # M = 5
    # 방문할 수 있는 칸 : 4

    # M = 6
    # 방문할 수 있는 칸 : 4

    # M = 7
    # 방문할 수 있는 칸 : 5

    # M = 8
    # 방문할 수 있는 칸 : 6

    # M이 7보다 크게 되면 M - 7 + 5라는 규칙을 찾을 수 있다.
