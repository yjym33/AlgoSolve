# 정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 이다.

#     a. X가 5로 나누어 떨어지면 5로 나눈다.
#     b. X가 3으로 나누어떨어지면, 3으로 나눈다.
#     c. X가 2로 나누어떨어지면, 2로 나눈다.
#     d. X에서 1을 뺸다.

# 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최소값을 출력하시오.
# 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.

# 1. 26 - 1 = 25 (d)
# 2. 25 / 5 = 5 (a)
# 3. 5 / 5 = 1 (a)

# 입력 조건 : 첫째 줄에 정수 X가 주어진다 ( 1 =< X =< 30,000)
# 출력 조건 : 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

# 입력 예시 : 26                                출력 예시 : 3

# 문제 해설 (블로그 참조: Velog)

# 코드가 실행되는 시나리오는 다음과 같다.

# N = 10 => 9 => 3 => 1 = 출력 3
# N = 4 => 3 => 1 = 출력 2
# N = 8 => 4 => 3 => 1 = 출력 3

# 이 문제를 처음 접한 사람이라면 본인이 생각한 시나리오와 다를 수 있을 것이다.
# 이제부터 시나리오처럼 코드를 작성해보곘다.

# 1. 먼저 N에 입력 값을 저장한다.
#       N = int(input())

# 2. 다음은 최소 값의 경로를 저장 (메모제이션) 하기 위해 dp 라는 배열을 선언 해주겠다.
#       dp = [0, 0, 1, 1]
# 왜 배열에 할당한 값이 0,0,1,1 이냐고 묻는다면 첫번째 0은 단순 인덱스를 맞춰주기 위함이고 나머지는 
# N이 1일때의 출력 값, N이 2일때의 출력 값, N이 3일 때의 출력 값을 순서대로 할당한 것이다.

# 3. 다음은 코드를 보며 설명을 할것이다.
# for i in range(4, N + 1):
#     dp.append(dp[i-1]+1)
#     if  i % 2 == 0:    dp[i] = min(dp[i//2]+1, dp[i])
#     if  i % 3 == 0:    dp[i] = min(dp[i//3]+1, dp[i])

# 위의 코드처럼 최소값을 비교하기 위한 조건은 3가지가 있다.
#   dp[인덱스] = dp[인덱스//3]
#   dp[인덱스] = dp[인덱스//2]
#   dp[인덱스] = dp[인덱스-1] + 1

# 만약 반복문을 2 또는 3부터 실행해준다면 오류가 발생하거나 출력 값이 올바르지 않을 것이다
# ex) dp[2//3] -> 오류가 발생
# 그렇기 떄문에 dp 배열에는 필요한 최소한의 값만을 넣어두고 그 값을 기반으로 반복하여 N까지의 결과를 할당할 수 있는 것이다.

# 반복문이 종료되면 dp의 (N+1)번쨰 값을 출력해준다.
# print(dp[N])

# 전체 코드 (블로그 풀이)

# N = int(input())
# dp = [0, 0, 1, 1]

# for i in range(4, N+1):
#     dp.append(dp[i-1]+1)
#     if  i%2 == 0:   dp[i] = min(dp[i//2]+1, dp[i])
#     if  i%3 == 0:   dp[i] = min(dp[i//3]+1, dp[i])

# print(dp[N])

# 전체 코드 (책 풀이)

# 정수 X를 입력받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)
    
print(d[x])


